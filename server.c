#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>
#include <signal.h>
#include <math.h>
#include <time.h>
#include <unistd.h> //defines miscellaneous symbolic constants and types
#include <sys/types.h> //defines a collection of typedef symbols and structures
#include <sys/socket.h> //sockets header
#include <netinet/in.h> //Internet address family
#include <errno.h> //used for error indication
#include <arpa/inet.h> //makes available the type in_port_t and the type in_addr_t


/* contains unique ID of message type and the content of the message */
struct Message 
{
	int type_id;
	char msg[1000];
};

typedef struct Message Message;

/*
 Format : [MESSAGE_TYPE_ID][MESSAGE_CONTENT]
 concatenation of elements of "struct Message",store it in a char array and return it.
 */
char* message_to_char(Message message){
	int size=1001;
	char *output = (char*) malloc(size*sizeof(char));
	output[0] = (char) (48 + message.type_id);
	strcpy(output+1, message.msg);
	return output;
}


/*
 - extracting message from input char array and TYPE_ID, return pointers to "struct Message"
 - also, mapping them to respective elements of "struct Message" 
 */
Message* char_to_message(char* input){
	int size=sizeof(Message);
	Message* output = (Message*) malloc(size);
	strcpy(output->msg, input + 1);
	output->type_id = (int) (input[0] - 48);
	return output;
}


/* in char array, each byte is converted to it's binary representation and storing the result in an integer array
example:
msg = "XYZ";
(binary representation of X:1011000,Y:1011001,Z:1011010)
returns array = {1,0,1,1,0,0,0,1,0,1,1,0,0,1,1,0,1,1,0,1,0} 

blen = 21
(0 padding done to make multiple of 6 for base64 encoding, here blen=21 making it multiple of 3 0's padded
 so 21+3=24 and 24/6=4)
len = 4

blen = length of returned int array
len = length of base64 encoded msg generated by encoding msg.
*/
int *char_to_bits(char *msg, int *len, int *blen)
{
	int n = strlen(msg);
	int sz = n<<3;
	if(sz%6!=0)
		sz += (6 -(n*8)%6);
	*len = sz/6;
	if(n%3==1)
		(*len)+=2;
	else if(n%3==2)
		(*len)+=1;
	*blen = sz;
	int idx = 0,i=0,j;
	int *bits = (int *)malloc(sz*sizeof(int));
	while(i<n)
	{
		int p  = (int)msg[i];
		j=0;
		while(j<8)
		{
			bits[idx + 7-j] = (p%2);
			p/=2;
			j++;
		}
		idx += 8;
		i++;
	}
	i=idx;
	while(i<sz)
	{
		bits[i]=0;
		i++;
	}
	return bits;
}

/*for each integer value respective char value is returned in base64 encoding*/
char mapchar(int i)
{
    if(i < 26)
        return 'A' + i;
    if(i < 52)
        return 'a' + i -26;
    if(i < 62)
        return '0' + i - 52;
    return (i == 62)? '+':'/';
}


/*
 -binary value is converted from bits to bytes and corresponding ascii character is returned
 - arr_bits = integer array conataing 0's and 1's.
 */
char binary_to_char(int *arr_bits, int s,int e)
{
	int i=e, p = 0;
	while(i>=s)
	{
		p = p + arr_bits[i]*(1 << e-i);
		i--;
	}
	return mapchar(p);
}


/*
 - data array- character array containg elements, needs to be encoded
 - character array data is encoded to base64 encoded format 
 - then, after modification the encoded data in original array is returned
 */
void encode(char *data)
{
	int f,i=0,j;
	int n = strlen(data);
	char msg[1000];
	strcpy(msg, data);
	while(i<strlen(data))
	{
		if(data[i] == '\r' || data[i] == '\n' || data[i] == '\0'){
			f = i;
			break;
		}
		i++;
	}
	
	int bits_len;

	int encoded_len;
	msg[f] = '\0';
	int *bits = char_to_bits(msg, &encoded_len, &bits_len);
	char *encoded_msg = (char*) malloc((encoded_len+n-f+1)*sizeof(char));
	i=0;
	while(i<bits_len/6)
	{
		encoded_msg[i] = binary_to_char(bits, i*6, i*6 + 5);
		i++;
	}
	i=bits_len/6;
	while(i<encoded_len)
	{
			encoded_msg[i] = '=';
			i++;
	}

	encoded_msg[encoded_len] = '\0';
	int p = encoded_len;
	i=p;
	while(i<p+(n-f+1))
	{
		encoded_msg[i] = data[f + i-p];
		i++;
	}
		
	strcpy(data, encoded_msg);
    free(encoded_msg);
	free(bits);
}

/*
 -converting decimal to binary representation
 -the binary reprsentation in char array temp[i] is returned
*/
void decimalToBinary_d(long n, char temp[][6], int I ) {
    int remainder; 
    int j = 5;
	for(;n!=0;n = n/2)
	{
		remainder = n%2;
		temp[I][j] = (remainder == 0)?'0':'1';
		j--;
	}

    int i=0;
	while(i<=j)
	{
		temp[I][i] = '0';
		i++;
	}
}


/*
 - in binary array of type int is converted to it's decimal form and 
   returning the result as integer
*/
int binaryToDecimal_d(char *t ) 
{
    int decimal = 0;
	for(int i=0;i<8;++i)
	{
		if(t[7-i] == '1')
        	decimal +=(int) (1 << i);
	}
    return decimal;
 
}


/*
  - creating a copy of message which contains the MESSAGE excluding '\0' , '\n' , '\r'
  - then, find the total length of the MESSAGE considering the number of "=" appended
  - converting the encoded binary data into decimal form
  - after encoding is done, add the special characters '\0' , '\n' , '\r' at the end
 */
void decode(char *msg)
{
	char EncodedMessage[100000];
	int f,x=0;
	while(x<strlen(msg))
	{
		if(msg[x] == '\r' || msg[x] == '\n' || msg[x] == '\0'){
			f = x;
			break;
		}
		x++;
	}
	x=0;
	while(x<f)
	{
		EncodedMessage[x] = msg[x];
		x++;
	}
	EncodedMessage[f] = '\0';
	int len = strlen(EncodedMessage);
	int alen = len,sub = 0;
	if(EncodedMessage[len-1] == '='){
		if(EncodedMessage[len-2] != '='){
			alen = len-1;
			sub = 2;
		}
		if(EncodedMessage[len-2] == '='){
			alen = len-2;
			sub = 4;
		}
	}
	alen = (alen*6 - sub)/8;

    char code[64] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	
	int i=0,j=0;
	char temp[100000][6];
	char tempf[600000];

	while(i<strlen(EncodedMessage))
	{
		j=0;
		while(j<=63)
		{
			if(EncodedMessage[i]==code[j])
			{
				decimalToBinary_d(j,temp,i);
				break;
			}
			j++;
		}
		i++;
	}

	int remai = strlen(EncodedMessage) * 6  - strlen(temp[0]);
	i=0;
	if(remai == 6)
	{
		while(i<strlen(temp[0])-2)
		{
			tempf[i] = temp[0][i];
			i++;
		}
		// removing 2 0's
	}
	else if(remai == 12)
	{
		while(i<strlen(temp[0])-4)
		{
			tempf[i] = temp[0][i]; // removing 4 0's
			i++;
		}
	}
	else
	{
		while(i<strlen(temp[0]))
		{
			tempf[i] = temp[0][i];
			i++;
		}
	}

	int flag = strlen(tempf) / 8;
	char DecodedMessage[100000];
	int k = 0;
	int a = flag;
	for(;flag;flag--)
	{
		char x[8];
		int j=0;
		while(j<8)
		{
			x[j] = tempf[(a-flag)*8 + j];
			j++;
		}		    

		DecodedMessage[k++] = (char) binaryToDecimal_d(x);
	}

	DecodedMessage[alen] = '\0';
	
	int p = strlen(DecodedMessage);
	int n = strlen(msg);
	x=p;
	while(x<p+(n-f+1))
	{
		DecodedMessage[x] = msg[f + x-p];
		x++;
	}
	strcpy(msg, DecodedMessage);
	i=0;
	while(i< 100000)
	{
		DecodedMessage[i] = '\0';
		i++;
	}
	i=0;
	while(i< 600000)
	{
		tempf[i] = '\0';
		i++;
	}
}


pid_t parent_pid; // to store pid of parents before forking is done

/* in the descriptor,writting n-bytes */
ssize_t writen(int fd, const void *vptr, size_t n)
{
    size_t              nleft;
    const char  *ptr;
	ssize_t             nwritten;
    ptr = (char *)vptr;
	for(nleft = n;nleft > 0;nleft -= nwritten)
	{
		if ( (nwritten = write(fd, ptr, nleft)) <= 0) {
            if (errno == EINTR)
                nwritten = 0; // we call wtite() again
            else
                return(-1);// return -1 for error
        }
        ptr =ptr+ nwritten;
	}
    return(n);
}

// returns true if M starts with "close"
bool isClose(char *M)
{
	if(strlen(M) < 5)
		return false;
	else if(M[0] != 'c')
		return false;
	else if(M[1] != 'l')
		return false;
	else if(M[2] != 'o')
		return false;
	else if(M[3] != 's')
		return false;
	else if(M[4] != 'e')
		return false;
	return true;
}


typedef struct sockaddr SA;

/*
 - waiting for message from client side
 - from the client side recieve the message, structure Message is created from the character array received
 - CLIENT ID, MESSAGE_ID  is displayed
 - content of the "Message" is decoded
 - another instance of "Message" is created corresponding to acknowledgement("ACK") and storing 
   the content and message type ID
 - the message is converted into char array and sends to client
*/
void str_server(int sockfd,char *clientname,int *cno)
{
	ssize_t n;
	char buf[1000];
	bzero(buf, 1000*sizeof(char));
	

	do{
		for(;(n = read(sockfd, buf, 1000)) > 0;)
		{
			Message* message = char_to_message(buf);
			printf("\nBase64 Encrypted text from client_%d received %s : \n",*cno, clientname);
			Message* message_here;
			printf("Type_id: %d\nmessage: %s\n\n",message->type_id, message->msg);
			printf("Base64 Encoded message : %s",message->msg);
			decode(message->msg);
			printf("Decoded message : %s",message->msg);
			Message smessage;
			smessage.type_id = 2;
			snprintf(smessage.msg, sizeof(smessage.msg),"ACK\r\n");
			encode(smessage.msg);
			char *message_com = message_to_char(smessage);
			if(writen(sockfd, message_com, strlen(message_com))!=strlen(message_com))	// handles writen errors
			{
				perror("writen error");
			}
			free(message_com);
			
			bzero(buf, sizeof(buf));

			if(isClose(message->msg)){
				close(sockfd);
				printf("client sent close.\n");
				printf("closing socket....\n");
				exit(1); // to check close server. 
			}
			free(message);

		}
	}while(n<0);
}


/* if s is an integer, return true else false */
bool is_int(char *s)
{
	int i=0;
	while(i<strlen(s))
	{
		if(s[i] < '0' || s[i] > '9')
			return false;
		i++;
	}
	return true;
}


int Lfd,Cfd;

/*
 from the server side, CTRL+C is in order to sent close signal to client side to end the server's process
 which server is serving the client and release resources of socket
*/
void signalHandler(int signalValue)
{   
	printf("sending close to clients...\n");
	char sendline[1000];
	bzero(sendline, sizeof(sendline));
	snprintf(sendline, sizeof(sendline), "close\r\n");
	Message message;
	message.type_id = 3;
	encode(sendline);
	strcpy(message.msg, sendline);
	char* message_com = message_to_char(message);
	if(!(getpid() == parent_pid))
	{ 
		if(writen(Cfd, message_com, strlen(message_com))!=strlen(message_com))	// handles writen errors
			{
				perror("writen error");
			}
	}
	if(getpid() == parent_pid)
		printf("closing sockets....\n");
	free(message_com);

	close(Lfd);
	if(!(getpid() != parent_pid))
	{
		printf("exiting...\n");
	}
	exit(0);
}


int main(int argc, char **argv){
	
	parent_pid = getpid();
	if(argc==1)
	{
		printf("usage: <executable> <port>\n");
	}
	
	signal(SIGINT, signalHandler);
	 
	if(argc != 2){
		printf("usage: <executable> <port>\n");
		exit(1);
	}
	else if(!is_int(argv[1])){
		printf("port must be an unsigned integer\n");
		exit(1);
	}	

	int serv_port = atoi(argv[1]);

	if(serv_port < 0){
		printf("port number must be between 0 and 65535.\n");
		exit(1);
	}
	else if(serv_port > 65535)
	{
		printf("port number must be between 0 and 65535.\n");
		exit(1);
	}
	printf("creating socket...\n");

	int listenfd, connfd,lisfd;
	pid_t child_pid;
	socklen_t cli_len;
	struct sockaddr_in cli_addr, serv_addr;
   
	listenfd = socket(AF_INET, SOCK_STREAM, 0);
	Lfd = listenfd;
	printf("socket created....\n");
	bzero(&serv_addr, sizeof(serv_addr));

	serv_addr.sin_family = AF_INET;
	lisfd=connfd;
	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	serv_addr.sin_port = htons(serv_port);
	lisfd=listenfd;
    
	bind(listenfd, (SA *) &serv_addr, sizeof(serv_addr));

	listen(listenfd, 10);
	printf("listening --> at port number : %d\n", serv_port);
	// to store connected clients IP in it after fork.
    char clientname[1000];
	int cno=1;
	while(true){
		char client[100];
		cli_len = sizeof(cli_addr);
		connfd = accept(listenfd, (SA *) &cli_addr, &cli_len);
		inet_ntop(AF_INET, &cli_addr.sin_addr, client, 100);
		strcpy(clientname, client);
		printf("\nclient_%d %s connected\n",cno, client);
		if((child_pid = fork()) == 0 )
		{
			Cfd = connfd;
			close(listenfd);
			str_server(connfd,clientname,&cno);
			exit(0);
		}
		else if(getpid() == parent_pid)
			close(connfd);
		cno++;
	}
	return 0;
}
