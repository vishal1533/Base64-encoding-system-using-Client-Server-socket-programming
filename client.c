#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>
#include <signal.h>
#include <math.h>
#include <unistd.h> //defines miscellaneous symbolic constants and types
#include <sys/types.h> //defines a collection of typedef symbols and structures
#include <sys/socket.h> //sockets header
#include <netinet/in.h> //Internet address family
#include <errno.h> //used for error indication
#include <arpa/inet.h> //makes available the type in_port_t and the type in_addr_t


// contains the content of the message and unique ID of message type
struct Message 
{
	int type_id;
	char msg[1000];
};
typedef struct Message Message;
typedef struct sockaddr SA;


/*returns the legth of the input string*/
int my_strlen(const char *s)
{
    unsigned int count = 0;
    while(*s!='\0')
    {
        count++;
        s++;
    }
    return count;
}

/* copy input string to destination string*/
void strcpy2(char dest[], const char source[]) 
{
    int i = 0;
    while ((dest[i] = source[i]) != '\0')
    {
        i++;
    } 
}

/*
 Format : [MESSAGE_TYPE_ID][MESSAGE_CONTENT]
 concatenation of elements of "struct Message",store it in a char array and return it.
 */
char* message_to_char(Message message)
{
	int size=1001;
	char *output = (char*) malloc(size * sizeof(char));
	output[0] = (char) (48 + message.type_id);// asciii value of 0 48
	strcpy(output+1, message.msg);
	return output;
}


/*
 - extracting message from input char array and TYPE_ID, return pointers to "struct Message"
 - also, mapping them to respective elements of "struct Message" 
 */
Message* char_to_message(char* input)
{
	int size=sizeof(Message);
	Message* output = (Message*) malloc(size);
	strcpy(output->msg, input + 1);
	output->type_id = (int) (input[0] - 48);
	return output;
}

/* in char array, each byte is converted to it's binary representation and storing the result in an integer array
example:
msg = "XYZ";
(binary representation of X:1011000,Y:1011001,Z:1011010)
returns array = {1,0,1,1,0,0,0,1,0,1,1,0,0,1,1,0,1,1,0,1,0} 

blen = 21
(0 padding done to make multiple of 6 for base64 encoding, here blen=21 making it multiple of 3 0's padded
 so 21+3=24 and 24/6=4)
len = 4

blen = length of returned int array
len = length of base64 encoded msg generated by encoding msg.
*/
int *char_to_bits(char *msg, int *len, int *blen)
{
	int n = my_strlen(msg);
	int sz = n<<3;
	int cnt=0;
	if(sz%6!=0)
	{
		int ans=6 -sz%6;
		++cnt;
		sz += ans;
	}
	*len = sz/6;
	if(n%3==1)
		(*len)=(*len)+2;
	else if(n%3==2)
		(*len)=(*len)+1;
	*blen = sz;
	int *bits = (int *)malloc(sz*sizeof(int));
	int idx = 0,i=0,j,temp;
	while(i<n)
	{
		int p = (int)msg[i];
		j=0;
		while(j<8)
		{
			temp=idx + 7-j;
			bits[temp] = (p%2);
			p/=2;
			++j;
		}
		idx += 8;
		++i;
	}
	i=idx;
	while(i<sz)
	{
        bits[i] = 0;
		++i;
	}
	return bits;
}

/*for each integer value respective char value is returned in base64 encoding*/
char mapchar(int i)
{
    char c1= 'A' + i;
	char c2= 'a' + i -26;
	char c3= '0' + i - 52;
    if(i < 26)
        return c1;
    else if(i < 52)
        return c2;
    else if(i < 62)
        return c3;
    else
	{
		if(i==62)
		return '+';
		else
		return '/';
	}
}

/*
 -binary value is converted from bits to bytes and corresponding ascii character is returned
 - arr_bits = integer array conataing 0's and 1's.
 */
char binary_to_char(int *bits, int s,int e) 
{
	int p = 0,i=e;
	while(i>=s)
	{
		int temp= (1 << e-i);
		p = p + bits[i]* temp;
		--i;
	}
	char ans= mapchar(p);
	return ans;
}



/*
 - data array- character array containg elements, needs to be encoded
 - character array data is encoded to base64 encoded format 
 - then, after modification the encoded data in original array is returned
 */
void encode(char*data) 
{
	char msg[1000];
	int n = my_strlen(data);
	int f=0,i=0,j=0;
	strcpy(msg, data);
    int wlength=my_strlen(data);

	while(i<wlength) 
	{
		if(data[i] == '\r') 
		{
			f = i;
			break;
		}
		if(data[i] == '\0') 
		{
			f = i;
			break;
		}
		if(data[i] == '\n') 
		{
			f = i;
			break;
		}
		++i;
	}
	msg[f] = '\0';

	int encoded_len=0, bits_len=0;
	int *bits = char_to_bits(msg, &encoded_len, &bits_len);
	int size= (encoded_len+n-f+1);
	char *encoded_msg = (char*) malloc(size * sizeof(char));
    
	i=0;
	while(i<bits_len/6)
	{
	   int val = i*6;
       encoded_msg[i] = binary_to_char(bits, val, val + 5);
	   ++i;
	}
    
	i=bits_len/6;
	while(i<encoded_len)
	{
       encoded_msg[i] = '=';
	   ++i;
	}
    
	int p = encoded_len;
	encoded_msg[encoded_len] = '\0';
    int limit=p+(n-f+1);
	i=p;
	while(i<limit)
	{
       encoded_msg[i] = data[f + i-p];
	   ++i;
	}		

	strcpy(data, encoded_msg);
    free(encoded_msg);
	free(bits);
}


/*
 -converting decimal to binary representation
 -the binary reprsentation in char array temp[i] is returned
*/
void decimalToBinary_d(long n1, char temp[][6], int I ) 
{ 
    int j = 5,i=0;
	int remainder=0;
    for(long n=n1;n != 0;n = n/2) 
	{
        remainder = n%2;
        temp[I][j]= remainder == 0 ? '0' : '1';
		j--;
	}
    
	while(i<=j)
	{
       temp[I][i] = '0';
	   ++i;
	}
}


/*
 - in binary array of type int is converted to it's decimal form and 
   returning the result as integer
*/
int binaryToDecimal_d(char *t )
{
    int decimal = 0,j=8;
    for(int i=0;i<j;i++) 
	{
        if(t[7-i] == '1')
		{
		  int temp= (int) (1 << i);
          decimal += temp;
		}
    }
    return decimal;
}


/*
  - creating a copy of message which contains the MESSAGE excluding '\0' , '\n' , '\r'
  - then, find the total length of the MESSAGE considering the number of "=" appended
  - converting the encoded binary data into decimal form
  - after encoding is done, add the special characters '\0' , '\n' , '\r' at the end
 */
void decode(char *msg)
{
	char EncodedMessage[100000];
	int f=0,x=0;

	while(x<my_strlen(msg))
	{
		if(msg[x] == '\r')
		{
			f = x;
			break;
		}
		if(msg[x] == '\0')
		{
			f = x;
			break;
		}
		if(msg[x] == '\n')
		{
			f = x;
			break;
		}
		++x;
	}
    
	x=0;
	while(x<f)
	{
		EncodedMessage[x] = msg[x];
		++x;
	}
    
	int sub = 0;
	EncodedMessage[f] = '\0';
    
	int len = my_strlen(EncodedMessage);
	int alen = len;
	if(EncodedMessage[len-1] == '=')
	{
		
		if(EncodedMessage[len-2] != '=')
		{
			alen = len-1;
			sub = 2;
		}
		else if(EncodedMessage[len-2] == '=')
		{
			alen = len-2;
			sub = 4;
		}
	}
	int vall= alen*6 - sub;
	alen = vall/8;
	int i=0,j=0;
	char temp[100000][6];
    char code[64] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	
	char tempf[600000];
    while(i<my_strlen(EncodedMessage))
	{
		j=0;
		int flg=0;
		while(j<64)
		{
			if(EncodedMessage[i]==code[j]) 
			{
				decimalToBinary_d(j,temp,i);
				flg=1;
			}
            if(flg==1)
			break;
			++j;	
		}
		++i;
	}
	
    int len1= my_strlen(EncodedMessage), len2= my_strlen(temp[0]);
	int remai = len1 * 6  - len2;
    
	int count =0;
	if(remai == 12) // removed four 0
	{
		count=0;
		while(count < len2-4)
		{
		   tempf[count] = temp[0][count];
		   ++count;
		}
				
	}
	else if(remai == 6) // removed two 0
	{
		count=0;
		while(count<len2) 
		{
           tempf[count] = temp[0][count];
		   ++count;
		}	
	}
	else 
	{
		count=0;
		while(count<len2)
		{
			tempf[count] = temp[0][count];
			++count;
		}
	}
	
	int vlen = my_strlen(tempf) / 8;
	int a = vlen;
	int k = 0;
	char DecodedMessage[100000];
	for(int flag=vlen;flag;flag--)
	{
		char x[8];
		int j=0;
		while(j<8)
		{
			int ans= (a-flag)*8;
			x[j] = tempf[ans + j];
			++j;
		}
		DecodedMessage[k++] = (char) binaryToDecimal_d(x);
	}

	DecodedMessage[alen] = '\0';
	
	int p = my_strlen(DecodedMessage);
	int n = my_strlen(msg);
    x=p;
	while(x<p+(n-f+1))
	{
	   int val= f + x-p;
       DecodedMessage[x] = msg[val];
	   ++x;
	}

	strcpy(msg, DecodedMessage);
	i=0;
    while(i< 100000)
	{
       DecodedMessage[i] = '\0';
	   ++i;
	}
	i=0;
	while(i< 600000)
	{
       tempf[i] = '\0';
	   ++i;
	}
}

int	read_cnt;
bool isConnected;
ssize_t my_read(int fd, char *ptr)
{
	int tt=0;
	char *read_ptr;
	char read_buf[1000];
	if(read_cnt <= 0)
	{
		while(true){
			if ( (read_cnt = read(fd, read_buf, sizeof(read_buf))) < 0) 
			{
				if (errno == EINTR)		
					continue;
				return -1;

			}
			else if (read_cnt == 0)		
				return 0;
			read_ptr = read_buf;
			break;
		}
	}
	read_cnt=read_cnt-1;
	*ptr = *read_ptr++;
	return 1;
}

/*
  - stream of fd is read till we encounter "\n", EOF or error occcurs or maxlen characters are read
  - store "\n" similar to fgets
 */
ssize_t readline(int fd, void *vptr, size_t maxlen)
{
	char c, *ptr= (char *)vptr;
    int tt=0;
	ssize_t	n=1, rc;
    
	while(n < maxlen)
	{
		if (rc == 0) 
		{
			*ptr = 0;
			return n - 1; // EOF, n - 1 bytes were read
		} 
        else if ( (rc = my_read(fd, &c)) == 1) 
		{
			*ptr++ = c;
			if (c == '\n')
				break;	// newline is stored, like fgets() 
			else
			++tt;
		} 
		else
			return -1;	//error, errno set by read()
		++n;
	}

	*ptr = 0; //null terminate like fgets() 
	return n;
}


/* readline errors are handled*/
ssize_t Readline(int fd, void *ptr, size_t maxlen) 
{
	ssize_t	n = readline(fd, ptr, maxlen);
	int count=0;
	if ( n < 0)
	{
		printf("readline error\n");
		++count;
		exit(1);
	}
	return n;
}

/* in the descriptor,writting n-bytes */
ssize_t writen(int fd, const void *vptr, size_t n) 
{
    size_t nleft = n;
    ssize_t nwritten;
    const char  *ptr = (char *)vptr;

    for(;nleft > 0;) 
	{
        if ( (nwritten = write(fd, ptr, nleft)) <= 0) 
		{
            if (errno != EINTR)
                return(-1); // error 
            else if(errno == EINTR)
			    nwritten = 0; // and call write() again
        }
        ptr   += nwritten;
        nleft -= nwritten;
    }
    return n;
}

// returns true if M starts with "close"
bool isClose(char *M)
{
	if(my_strlen(M) < 5 || M[0] != 'c' || M[1] != 'l' || M[2] != 'o' || M[3] != 's' || M[4] != 'e')
	  return false;
	else
	return true;
}

/*
  - line by line input are taken
  - decides the MESSAGE_TYPE, creating "struct Message" structure, copy all the data to it
  - encoding the message field of "struct Message" (content of the Message)
  - converts the "struct Message" into char array i.e. message_com
  - sends message_com (char array) to server side and waits for server to send the message 
  - "struct Message" structure (cmessage) is created from receiving char array and decodes the4
    data of received message i.e. cmessage -> msg
  - also checks if the message contains the command to close the communication, if yes then close it
*/
void str_cli(FILE *fp, int sockfd)
{
	char sendline[1000];
	int count=0;
	char recvline[1000];
	for(;fgets(sendline, 1000, fp);)
	{
		Message message;
		if(isClose(sendline))
		message.type_id = 3;
		else
		message.type_id = 1;
		strcpy(message.msg,sendline);
		encode(message.msg);
		char *message_com = message_to_char(message);
		if (writen(sockfd, message_com, my_strlen(message_com)) != my_strlen(message_com))
		{
        	perror("writen error");
		}

		for(;recv(sockfd, recvline, 1000,0) <= 0;)
		{
			 printf("\nserver terminated prematurely\n");
			 close(sockfd);	
			 printf("closing sockets....\n");
			 printf("exiting....\n");
			 exit(0);
		}

		Message* cmessage = char_to_message(recvline);
		printf("\nMessage received from server:\n");
		free(message_com);
		printf("Type_id: %d\nEncoded message for ACK: %s\n\n",cmessage->type_id, cmessage->msg);
		decode(cmessage->msg);
		bool is_close = isClose(cmessage->msg); 
		if(is_close)
		{
			printf("\nserver terminated prematurely\n");
			close(sockfd);	
			printf("closing socket....\n");
			printf("exiting....\n");
			exit(0);	
		}
		++count;
		fputs(cmessage->msg, stdout);
		free(cmessage);

		if(isClose(sendline))
		{
			printf("closing socket....\n");
			close(sockfd);
			printf("exiting client....\n");
			exit(1);
		}
		else
		count=0;
	}
}


/* if s is an integer, return true else false */
bool is_int(char *s)
{
	int i=0;
	bool flag=false;
	while(i<my_strlen(s))
	{
		if(s[i] < '0' || s[i] > '9')
			return false;
		else
        flag=true;
		++i;
	}
	return true;
}


/*
 from the server side, CTRL+C is in order to sent close signal to client side to end the server's process
 which server is serving the client and release resources of socket
*/
typedef struct sockaddr SA;
int	read_cnt;
bool isConnected;
void signalHandler(int signalValue)
{
	int signl=0;
	int cfd;
	if(!isConnected)
	{
		printf("Error connecting to server\n");
		exit(0);
	}
	else
    ++signl;
	printf("sending close to server..\n");
	char sendline[1000];
	int siz=sizeof(sendline);
	snprintf(sendline, siz, "close");
	Message message;
	message.type_id = 3;
	encode(sendline);
	strcpy(message.msg, sendline);
	char* message_com = message_to_char(message);
	if (writen(cfd, message_com, my_strlen(message_com)) != my_strlen(message_com))
	{
        perror("writen error");
	}
	free(message_com);
	printf("closing client sockets....\n");
	close(cfd);
	printf("exiting..\n");
	exit(0);
}


int main(int argc, char **argv)
{
	int sockd;
	// set signal handler for ctrl-c interupt
	signal(SIGINT, signalHandler); 
	
	if(argc != 3)
	{
		printf("usage: <executable> <IP address> <port>\n");
		exit(1);
	}
	else if(!is_int(argv[2]))
	{
		printf("port must be an unsigned integer\n");
		exit(1);
	}	

	// take server port and check for errors.
	int serv_port = atoi(argv[2]);
	if(serv_port < 0)
	{
		printf("port number must be between 0 and 65535.\n");
	}
	else if(serv_port > 65535)
	{
		printf("port number must be between 0 and 65535.\n");
	}


	// create socket.
	int sockfd;
    int scadrr;
	printf("Note: to close connection, type --> close\n\nWaiting for connection...\n");
	struct sockaddr_in serv_addr;
	isConnected = false;
	sockfd = socket(AF_INET, SOCK_STREAM, 0);

	// fill socket address structure
	int sizee = sizeof(serv_addr);
	bzero(&serv_addr, sizee);
	serv_addr.sin_family = AF_INET;
	scadrr= sockfd;
	serv_addr.sin_port = htons(serv_port);
	inet_pton(AF_INET, argv[1], &serv_addr.sin_addr);

	// connect to server
	struct timeval timeout;
	timeout.tv_sec  = 7;  // after 7 seconds connect() will timeout
	timeout.tv_usec = 0;
	setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));
	int ans=connect(sockfd, (SA *)&serv_addr, sizeof(serv_addr));
	if(!ans)
	printf("Connection is established....\n");

	isConnected = true;

	str_cli(stdin, sockfd);

	return 0;
}